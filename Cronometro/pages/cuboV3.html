<!DOCTYPE html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>QiYi Smart Cube JS + Cron√≥metro</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/aes-js@3.0.0/index.min.js"></script>
  <script type="module" src="https://cdn.cubing.net/v0/js/cubing/twisty"></script>
  <script type="module">
    import { randomScrambleForEvent } from "https://cdn.cubing.net/v0/js/cubing/scramble";

    window.obtenerScramble = async function () {
      const scramble = await randomScrambleForEvent("333");
      const s = scramble.toString();
    
      // Expande X2 -> X X para compararlo con lo que env√≠a el cubo
      const expanded = s.replace(/([UDLRFB])2/g, "$1 $1");
    
      window.scrambleMoves = expanded.trim().split(/\s+/);
      window.scrambleIndex = 0;
      window.lastError = false;
    
      document.getElementById("scramble").textContent = s;
    
      if (window.actualizarScrambleUI) window.actualizarScrambleUI();
    };

    window.actualizarScrambleUI = function () {
      const cont = document.getElementById("scrambleProgress");
      cont.innerHTML = "";
    
      const moves = window.scrambleMoves || [];
      const idx = window.scrambleIndex || 0;
    
      moves.forEach((m, i) => {
        const span = document.createElement("span");
        span.textContent = m;
        if (i < idx) span.classList.add("done");
        if (i === idx) span.classList.add(window.lastError ? "error" : "current");
        cont.appendChild(span);
      });
    };
    

    window.obtenerScramble();
    document.getElementById("nuevoScramble").addEventListener("click", window.obtenerScramble);
  </script>
  <style>
    body {
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #111;
      color: #fff;
    }

    #log {
      background: #222;
      padding: 10px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      width: 90%;
      border-radius: 8px;
    }


    button {
      margin: 6px;
      padding: 10px 18px;
      border-radius: 8px;
      border: none;
      background: #333;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background: #555;
    }

    #scramble span {
      padding: 4px;
      margin: 2px;
      display: inline-block;
      border-radius: 4px;
    }

    #scrambleProgress span {
      padding: 4px;
      margin: 2px;
      display: inline-block;
      border-radius: 4px;
    }
    #scrambleProgress .done { background: #28a745; color: #fff; }
    #scrambleProgress .current { background: #ffc107; color: #000; }
    #scrambleProgress .error { background: #dc3545; color: #fff; }
    
  </style>
</head>

<body class="bg-dark text-light text-center p-4">
  <h1>QiYi Smart Cube JS + Cronometro</h1>
  <button id="connectBtn">üîó Conectar al cubo</button>
  <!-- Cron√≥metro -->
  <div class="display-3 my-4" id="cronometro">00:00.00</div>
     <!-- Scramble -->
  <div class="my-4">
    <h5>Scramble:</h5>
    <p id="scramble">Cargando...</p>
    <div id="scrambleProgress" class="scramble-progress"></div>
    <button class="btn btn-primary" id="nuevoScramble">Nuevo scramble</button>

  </div>
  
  <div id="log"></div>

  <script>
  
  // ===== Variables del cron√≥metro =====
      let cronometroInterval, tiempoInicio, corriendo = false;
      let scrambleMoves = [], scrambleIndex = 0;
      let detenerEnProximoAck = false;
      let inspeccionInterval, inspeccionRestante = 15, enInspeccion = false;
      
  
      function iniciarCronometro() {
        if (corriendo) return;
        tiempoInicio = Date.now();
        cronometroInterval = setInterval(actualizarCronometro, 10);
        corriendo = true;
		detenerEnProximoAck = true;
      }
      function detenerCronometro() {
        clearInterval(cronometroInterval);
        corriendo = false;
      }
      function actualizarCronometro() {
        const diff = Date.now() - tiempoInicio;
        const cs = Math.floor(diff / 10) % 100;
        const s = Math.floor(diff / 1000) % 60;
        const m = Math.floor(diff / 60000);
        document.getElementById("cronometro").textContent =
          `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${cs.toString().padStart(2,'0')}`;
      }

      function iniciarInspeccion() {
        detenerCronometro(); // por si acaso
        inspeccionRestante = 15;
        enInspeccion = true;
        document.getElementById("cronometro").textContent = `15`;
        inspeccionInterval = setInterval(() => {
          inspeccionRestante--;
          document.getElementById("cronometro").textContent = inspeccionRestante;
          if (inspeccionRestante <= 0) {
            clearInterval(inspeccionInterval);
            enInspeccion = false;
            iniciarInspeccion(); 
          }
        }, 1000);
      }
      
      function cancelarInspeccionYEmpezar() {
        if (enInspeccion) {
          clearInterval(inspeccionInterval);
          enInspeccion = false;
          iniciarCronometro();
        }
      }
      

   

       document.getElementById("nuevoScramble").addEventListener("click", () => {
         detenerCronometro();
         window.scrambleIndex = 0;
         window.lastError = false;
         if (window.actualizarScrambleUI) window.actualizarScrambleUI();
       });
       
  
      

  	//============= LOGICA CONECTAR CUBO =================// NO MODIFICAR //
  	
    const AES_KEY = new Uint8Array([87, 177, 249, 171, 205, 90, 232, 167, 156, 185, 140, 231, 87, 140, 81, 8]);
    let fff6Characteristic;
    let algHistory = "";
    const playerEl = document.getElementById("player");

    const log = msg => {
      const logEl = document.getElementById("log");
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    };

    // === AES helpers ===
    function encryptMessage(data) {
      const aes = new aesjs.ModeOfOperation.ecb(AES_KEY);
      let padded = data;
      if (data.length % 16 !== 0) {
        const padLen = 16 - (data.length % 16);
        padded = new Uint8Array([...data, ...new Array(padLen).fill(0)]);
      }
      const encrypted = new Uint8Array(padded.length);
      for (let i = 0; i < padded.length; i += 16) {
        encrypted.set(aes.encrypt(padded.slice(i, i + 16)), i);
      }
      return encrypted;
    }

    function decryptMessage(data) {
      const aes = new aesjs.ModeOfOperation.ecb(AES_KEY);
      const decrypted = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i += 16) {
        decrypted.set(aes.decrypt(data.slice(i, i + 16)), i);
      }
      return decrypted;
    }

    // === CRC16 Modbus ===
    function crc16Modbus(data) {
      let crc = 0xFFFF;
      for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
          if (crc & 1) {
            crc = (crc >> 1) ^ 0xA001;
          } else {
            crc >>= 1;
          }
        }
      }
      return crc;
    }

    // === Protocol helpers ===
    function buildAppHello(macReversed) {
      const data = new Uint8Array(19);
      data.set(macReversed, 11);
      return data;
    }

    function buildAckBodyFromMessage(decrypted) {
      const ackHead = decrypted.slice(2, 7);
      const ack = new Uint8Array(7);
      ack[0] = 0xfe;
      ack[1] = 9;
      ack.set(ackHead, 2);
      const crc = crc16Modbus(ack.slice(0, 7));
      const full = new Uint8Array(9);
      full.set(ack);
      full[7] = crc & 0xff;
      full[8] = crc >> 8;
      return full;
    }

    async function sendEncrypted(bytes) {
      const len = bytes.length + 2;
      const msg = new Uint8Array(len);
      msg[0] = 0xfe;
      msg[1] = len;
      msg.set(bytes, 2);
      const crc = crc16Modbus(msg.slice(0, len - 2));
      msg[len - 2] = crc & 0xff;
      msg[len - 1] = crc >> 8;
      const encrypted = encryptMessage(msg);
      //log("üì§ Sending encrypted: " + Array.from(encrypted).map(b => b.toString(16).padStart(2, '0')).join(" "));
      await fff6Characteristic.writeValueWithoutResponse(encrypted);
    }

    async function sendAck(decrypted) {
      const ack = buildAckBodyFromMessage(decrypted);
      await sendEncrypted(ack.slice(2));
      
      log("‚úÖ ACK sent");

      if (detenerEnProximoAck && corriendo) {
          detenerCronometro();
          detenerEnProximoAck = false;
        }
    }

    // === Diccionario movimientos ===
    const moveMap = {
      1: "L'", 2: "L",
      3: "R'", 4: "R",
      5: "D'", 6: "D",
      7: "U'", 8: "U",
      9: "F'", 10: "F",
      11: "B'", 12: "B",
    };
    
    // === Bluetooth connect ===
    document.getElementById("connectBtn").onclick = async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "QY-QYSC" }],
          optionalServices: [0xfff0]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(0xfff0);
        fff6Characteristic = await service.getCharacteristic(0xfff6);

        fff6Characteristic.addEventListener("characteristicvaluechanged", async e => {
          const value = new Uint8Array(e.target.value.buffer);
          const decrypted = decryptMessage(value);
         // log("üîπ RX dec: " + Array.from(decrypted).map(b => b.toString(16).padStart(2, '0')).join(" "));

          if (decrypted[0] === 0xfe && decrypted[2] === 0x02) {
            const battery = decrypted[35];
            //log("üîã Battery: " + battery + "%");
            await sendAck(decrypted);

          } else if (decrypted[0] === 0xfe && decrypted[2] === 0x03) {
            const move = decrypted[34];
            const battery = decrypted[35];
            const moveStr = moveMap[move];
            log("‚Ü™Ô∏è Move=" + move + " (" + moveStr + ") | üîã=" + battery + "%");

          if (enInspeccion) {
            cancelarInspeccionYEmpezar(); // si se mueve antes de terminar inspecci√≥n
          }
			
		  // --- Seguimiento del scramble ---
		  const moves = window.scrambleMoves || [];
		  let idx = window.scrambleIndex || 0;

		  const esperado = moves[idx];
		  if (esperado && moveStr === esperado) {
		    window.lastError = false;
		    idx += 1;
		    window.scrambleIndex = idx;

		    // Cuando completes TODO el scramble, inicia el cron√≥metro
		    if (idx === moves.length && !corriendo) iniciarCronometro();
		  } else {
		    window.lastError = true; // marca error en el paso actual
		  }
		  if (window.actualizarScrambleUI) window.actualizarScrambleUI();

            if (decrypted[91] === 1) await sendAck(decrypted);

          } else if (decrypted[0] === 0xfe && decrypted[2] === 0x04) {
            log("üîÑ Sync state recibido");
          }
        });

        await fff6Characteristic.startNotifications();
        log("üì° Notifications started.");

        // pedir MAC para enviar App Hello
        const macStr = "CC:A3:00:00:88:D4" //prompt("Introduce MAC del cubo (ej: CC:A3:00:00:25:13)","CC:A3:00:00:88:D4");
        const mac = macStr.split(":").map(h => parseInt(h, 16)).reverse();
        const appHello = buildAppHello(mac);
        await sendEncrypted(appHello);
        log("üì§ App Hello enviado.");

      } catch (err) {
        log("‚ùå Error: " + err);
      }
    };

    //=============== FIN LOGICA CONECTAR CUBO==============//

  </script>
</body>

</html>
