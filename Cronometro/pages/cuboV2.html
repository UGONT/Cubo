<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Cubo Rubik 3D con WebSocket</title>
<script type="module" src="https://cdn.cubing.net/v0/js/cubing/twisty"></script>
<style>
body { display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; background:#111; color:#fff; }
twisty-player { width:400px; height:400px; }
button { margin:4px; padding:8px 16px; border-radius:8px; border:none; background:#333; color:white; cursor:pointer; }
button:hover { background:#555; }
</style>
</head>
<body>
<h1>Cubo Rubik 3D</h1>

<twisty-player
    id="player"
    puzzle="3x3x3"
    hint-facelets="none"
    background="checkered"
    control-panel="none"
    tempo-scale="20">
</twisty-player>

<div>
    <button onclick="resetCubo()">Reset</button>
    <button onclick="co()">Conectar cubo</button>
</div>

<script>
const playerEl = document.getElementById("player");
let algHistory = "";

// Funci√≥n para mover el cubo
function moverCubo(moves) {
    if (!moves) return;
    algHistory = (algHistory + " " + moves).trim();
    playerEl.setAttribute("alg", algHistory);
    playerEl.play?.();
}

// Resetear cubo
function resetCubo() {
    algHistory = "";
    playerEl.setAttribute("alg", "");
}

// Conectar WebSocket
const socket = new WebSocket("ws://127.0.0.1:8765");


socket.onopen = () => {
    console.log("Conectado al servidor WebSocket");
};

socket.onmessage = (event) => {
    const move = event.data;
    console.log("Recibido movimiento:", move);
    moverCubo(move);
};

socket.onclose = () => console.log("Desconectado del WebSocket");
socket.onerror = (err) => console.error("WebSocket error:", err);


// === Configuraci√≥n del cubo ===
const CUBE_SERVICE_UUID = "0000fff0-0000-1000-8000-00805f9b34fb";
const CUBE_CHAR_UUID    = "0000fff6-0000-1000-8000-00805f9b34fb";

// === Clave AES (misma que en Python) ===
const CLAVE_AES = new Uint8Array([87, 177, 249, 171, 205, 90, 232, 167,
                                  156, 185, 140, 231, 87, 140, 81, 8]);

// === Diccionario de movimientos ===
const mapaMovimientos = {
  1:"L'",
  2:"L",
  3:"R'",
  4:"R",
  5:"D'",
  6:"D",
  7:"U'",
  8:"U",
  9:"F'",
  10:"F",
  11:"B'",
  12:"B",
};

// === Utilidades ===

function crc16_modbus(datos) {
  let crc = 0xFFFF;
  for (let b of datos) {
    crc ^= b;
    for (let i = 0; i < 8; i++) {
      if ((crc & 1) !== 0) {
        crc >>= 1;
        crc ^= 0xA001;
      } else {
        crc >>= 1;
      }
    }
  }
  return crc;
}

function construirAppHello(macInvertida) {
  let data = new Uint8Array(19);
  data.set(macInvertida, 11);
  return data;
}

function construirAckDesdeMensaje(descifrado) {
  let ackHead = descifrado.slice(2, 7); // 5 bytes
  let ack = new Uint8Array(7);
  ack[0] = 0xFE;
  ack[1] = 9;
  ack.set(ackHead, 2);
  let crc = crc16_modbus(ack);
  let full = new Uint8Array(9);
  full.set(ack, 0);
  full[7] = crc & 0xFF;
  full[8] = (crc >> 8) & 0xFF;
  return full;
}

function construirMensajeEncriptado(cuerpo) {
  let longitud = cuerpo.length + 2;
  let msg = new Uint8Array(longitud);
  msg[0] = 0xFE;
  msg[1] = longitud;
  msg.set(cuerpo, 2);
  let crc = crc16_modbus(msg.slice(0, longitud-2));
  msg[longitud-2] = crc & 0xFF;
  msg[longitud-1] = (crc >> 8) & 0xFF;

  // Encriptar con AES-ECB ‚Üí aqu√≠ conviene usar una lib AES en JS
  // (ej. crypto-js). Para simplificar, te lo dejo como pseudoc√≥digo:
  // return encriptarAES(msg);
  return msg; // TODO: implementar AES-ECB real
}

function parsearEstadoCubo(raw) {
  let colores = [];
  for (let b of raw.slice(0,27)) {
    colores.push(b & 0x0F);
    colores.push((b >> 4) & 0x0F);
  }
  return colores;
}

// === Conexi√≥n BLE ===
let caracteristicaCubo = null;

async function conectarCubo() {
  try {
    const dispositivo = await navigator.bluetooth.requestDevice({
      filters: [{ services: [CUBE_SERVICE_UUID] }]
    });

    const servidor = await dispositivo.gatt.connect();
    const servicio = await servidor.getPrimaryService(CUBE_SERVICE_UUID);
    caracteristicaCubo = await servicio.getCharacteristic(CUBE_CHAR_UUID);

    await caracteristicaCubo.startNotifications();
    caracteristicaCubo.addEventListener("characteristicvaluechanged", manejarNotificacion);

    console.log("‚úÖ Conectado al cubo!");

    // Enviar App Hello
    // Aqu√≠ habr√≠a que obtener la MAC invertida, en Web Bluetooth no siempre est√° accesible.
    // Puedes enviar un paquete gen√©rico como hace tu script Python.
    // let macInvertida = ...;
    // let appHello = construirAppHello(macInvertida);
    // let enc = construirMensajeEncriptado(appHello);
    // await caracteristicaCubo.writeValueWithoutResponse(enc);

  } catch (err) {
    console.error("‚ùå Error al conectar:", err);
  }
}

function manejarNotificacion(event) {
  let valor = new Uint8Array(event.target.value.buffer);
  console.log("üîπ RX:", valor);

  // Aqu√≠ deber√≠a ir la l√≥gica de descifrado (AES-ECB)
  let descifrado = valor; // TODO: descifrar real
  let tipo = descifrado[2];

  if (tipo === 0x02) {
    let estado = parsearEstadoCubo(descifrado.slice(7,34));
    let bateria = descifrado[35];
    console.log("üîã Bater√≠a:", bateria, "%", estado);
    // enviar ACK
    let ack = construirAckDesdeMensaje(descifrado);
    let enc = construirMensajeEncriptado(ack.slice(2));
    caracteristicaCubo.writeValueWithoutResponse(enc);

  } else if (tipo === 0x03) {
    let movimiento = descifrado[34];
    let bateria = descifrado[35];
    console.log("‚Ü™Ô∏è Movimiento:", movimiento, mapaMovimientos[movimiento], "üîã", bateria);

    if (mapaMovimientos[movimiento]) {
      twistyPlayer.experimentalAddMove(mapaMovimientos[movimiento]);
    }

    // enviar ACK si hace falta‚Ä¶
  } else if (tipo === 0x04) {
    let estado = parsearEstadoCubo(descifrado.slice(7,34));
    console.log("üîÑ Sync state:", estado);
  }
}

</script>
</body>
</html>
