<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>QiYi Smart Cube JS + 3D</title>
  <script src="https://cdn.jsdelivr.net/npm/aes-js@3.0.0/index.min.js"></script>
  <script type="module" src="https://cdn.cubing.net/v0/js/cubing/twisty"></script>
  <style>
    body {
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #111;
      color: #fff;
    }

    #log {
      background: #222;
      padding: 10px;
      max-height: 250px;
      overflow-y: auto;
      white-space: pre-wrap;
      width: 90%;
      border-radius: 8px;
    }

    twisty-player {
      width: 400px;
      height: 400px;
      margin: 20px 0;
    }

    button {
      margin: 6px;
      padding: 10px 18px;
      border-radius: 8px;
      border: none;
      background: #333;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background: #555;
    }
  </style>
</head>

<body>
  <h1>QiYi Smart Cube JS + 3D</h1>
  <button id="connectBtn">üîó Conectar al cubo</button>

  <twisty-player id="player" puzzle="3x3x3" hint-facelets="none" background="checkered" control-panel="none"
    tempo-scale="20">
  </twisty-player>
  <button onclick="resetCubo()">Reset</button>
  <div id="log"></div>

  <script>
    const AES_KEY = new Uint8Array([87, 177, 249, 171, 205, 90, 232, 167, 156, 185, 140, 231, 87, 140, 81, 8]);
    let fff6Characteristic;
    let algHistory = "";
    const playerEl = document.getElementById("player");

    const log = msg => {
      const logEl = document.getElementById("log");
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    };

    // === AES helpers ===
    function encryptMessage(data) {
      const aes = new aesjs.ModeOfOperation.ecb(AES_KEY);
      let padded = data;
      if (data.length % 16 !== 0) {
        const padLen = 16 - (data.length % 16);
        padded = new Uint8Array([...data, ...new Array(padLen).fill(0)]);
      }
      const encrypted = new Uint8Array(padded.length);
      for (let i = 0; i < padded.length; i += 16) {
        encrypted.set(aes.encrypt(padded.slice(i, i + 16)), i);
      }
      return encrypted;
    }

    function decryptMessage(data) {
      const aes = new aesjs.ModeOfOperation.ecb(AES_KEY);
      const decrypted = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i += 16) {
        decrypted.set(aes.decrypt(data.slice(i, i + 16)), i);
      }
      return decrypted;
    }

    // === CRC16 Modbus ===
    function crc16Modbus(data) {
      let crc = 0xFFFF;
      for (let b of data) {
        crc ^= b;
        for (let i = 0; i < 8; i++) {
          if (crc & 1) {
            crc = (crc >> 1) ^ 0xA001;
          } else {
            crc >>= 1;
          }
        }
      }
      return crc;
    }

    // === Protocol helpers ===
    function buildAppHello(macReversed) {
      const data = new Uint8Array(19);
      data.set(macReversed, 11);
      return data;
    }

    function buildAckBodyFromMessage(decrypted) {
      const ackHead = decrypted.slice(2, 7);
      const ack = new Uint8Array(7);
      ack[0] = 0xfe;
      ack[1] = 9;
      ack.set(ackHead, 2);
      const crc = crc16Modbus(ack.slice(0, 7));
      const full = new Uint8Array(9);
      full.set(ack);
      full[7] = crc & 0xff;
      full[8] = crc >> 8;
      return full;
    }

    async function sendEncrypted(bytes) {
      const len = bytes.length + 2;
      const msg = new Uint8Array(len);
      msg[0] = 0xfe;
      msg[1] = len;
      msg.set(bytes, 2);
      const crc = crc16Modbus(msg.slice(0, len - 2));
      msg[len - 2] = crc & 0xff;
      msg[len - 1] = crc >> 8;
      const encrypted = encryptMessage(msg);
      log("üì§ Sending encrypted: " + Array.from(encrypted).map(b => b.toString(16).padStart(2, '0')).join(" "));
      await fff6Characteristic.writeValueWithoutResponse(encrypted);
    }

    async function sendAck(decrypted) {
      const ack = buildAckBodyFromMessage(decrypted);
      await sendEncrypted(ack.slice(2));
      log("‚úÖ ACK sent");
    }

    // === Diccionario movimientos ===
    const moveMap = {
      1: "L'", 2: "L",
      3: "R'", 4: "R",
      5: "D'", 6: "D",
      7: "U'", 8: "U",
      9: "F'", 10: "F",
      11: "B'", 12: "B",
    };

    // =================================//

    
    // === Funci√≥n para mover cubo 3D ===
    let colaMovimientos = [];
    let ejecutando = false;
    
    function moverCubo(move) {
      if (!move) return;
    
      colaMovimientos.push(move);
      if (!ejecutando) {
        procesarCola();
      }
    }
    
    function procesarCola() {
      if (colaMovimientos.length === 0) {
        ejecutando = false;
        return;
      }
      ejecutando = true;
    
      const move = colaMovimientos.shift();
      algHistory = (algHistory + " " + move).trim();
      playerEl.setAttribute("alg", algHistory);
      playerEl.play?.();
    
      // Esperar un tiempo antes de disparar el siguiente movimiento
      const delayMs = 200; // Ajusta seg√∫n ritmo deseado (100‚Äì300 ms funciona bien)
      setTimeout(procesarCola, delayMs);
    }
    
    

    //======================================//
    

    function resetCubo() {
      algHistory = "";
      playerEl.setAttribute("alg", "");
    }

    // === Bluetooth connect ===
    document.getElementById("connectBtn").onclick = async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "QY-QYSC" }],
          optionalServices: [0xfff0]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(0xfff0);
        fff6Characteristic = await service.getCharacteristic(0xfff6);

        fff6Characteristic.addEventListener("characteristicvaluechanged", async e => {
          const value = new Uint8Array(e.target.value.buffer);
          const decrypted = decryptMessage(value);
          log("üîπ RX dec: " + Array.from(decrypted).map(b => b.toString(16).padStart(2, '0')).join(" "));

          if (decrypted[0] === 0xfe && decrypted[2] === 0x02) {
            const battery = decrypted[35];
            log("üîã Battery: " + battery + "%");
            await sendAck(decrypted);

          } else if (decrypted[0] === 0xfe && decrypted[2] === 0x03) {
            const move = decrypted[34];
            const battery = decrypted[35];
            const moveStr = moveMap[move];
            log("‚Ü™Ô∏è Move=" + move + " (" + moveStr + ") | üîã=" + battery + "%");

            // mover cubo 3D
            moverCubo(moveStr);

            if (decrypted[91] === 1) await sendAck(decrypted);

          } else if (decrypted[0] === 0xfe && decrypted[2] === 0x04) {
            log("üîÑ Sync state recibido");
          }
        });

        await fff6Characteristic.startNotifications();
        log("üì° Notifications started.");

        // pedir MAC para enviar App Hello
        const macStr = prompt("Introduce MAC del cubo (ej: CC:A3:00:00:25:13)");
        const mac = macStr.split(":").map(h => parseInt(h, 16)).reverse();
        const appHello = buildAppHello(mac);
        await sendEncrypted(appHello);
        log("üì§ App Hello enviado.");

      } catch (err) {
        log("‚ùå Error: " + err);
      }
    };
  </script>
</body>

</html>
